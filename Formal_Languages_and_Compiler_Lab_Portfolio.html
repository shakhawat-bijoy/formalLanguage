<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Formal Languages and Compiler Lab Portfolio</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 2rem;
        }
        pre {
            background: #f4f4f4;
            padding: 1rem;
            overflow-x: auto;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .sample-output {
            background: #e8f5e9;
            padding: 0.75rem;
            border-left: 5px solid #4caf50;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <h1>Formal Languages and Compiler Lab Portfolio</h1>
    <p><strong>Name:</strong> Shakhawat Hossain Bijoy<br>
       <strong>ID:</strong> 231071041<br>
       <strong>Department:</strong> CSE<br>
       <strong>Semester:</strong> 5th</p>
    <hr>
    <h2>Index</h2>
    <ul>
        <li><a href="#lab-task-01-string-operations-in-c">LAB TASK 01: String Operations in C</a></li>
        <li><a href="#lab-task-02-string-analysis">LAB TASK 02: String Analysis</a></li>
        <li><a href="#lab-task-03-regular-expressions">LAB TASK 03: Regular Expressions</a></li>
        <li><a href="#lab-task-04-lexical-analysis">LAB TASK 04: Lexical Analysis</a></li>
        <li><a href="#lab-task-05-ascii-&-names">LAB TASK 05: ASCII & Names</a></li>
        <li><a href="#lab-task-06-make-a-basic-calculator-that-follows-math-rules-(like-*-">LAB TASK 06: Make a basic calculator that follows math rules (like * </a></li>
        <li><a href="#lab-task-07-convert-expressions-into-tac-format,-which-is-used-in-">LAB TASK 07: Convert expressions into TAC format, which is used in </a></li>
        <li><a href="#lab-task-08-create-a-parser-in-c-to-analyze-and-evaluate-math-">LAB TASK 08: Create a parser in C to analyze and evaluate math </a></li>
        <li><a href="#lab-task-09--convert-normal-math-expressions-(like-a-+-b)-into-postfix-">LAB TASK 09:  Convert normal math expressions (like a + b) into postfix </a></li>
        <li><a href="#lab-task-10-deterministic-finite-automata-(dfa)">LAB TASK 10: Deterministic Finite Automata (DFA)</a></li>
    </ul><hr>
<p># Formal Languages and Compiler Lab Portfolio</p>
<br>
<p>**Name:** Shakhawat Hossain Bijoy  </p>
<p>**Student ID:** 231071041  </p>
<p>**Department:** CSE  </p>
<p>**Semester:** 5th  </p>
<br>
<hr>
<br>
<h2 id="overview">Overview</h2>
<br>
<p>This portfolio presents 10 comprehensive lab tasks focusing on fundamental concepts in formal languages and compiler design. The tasks progress from basic string manipulation to advanced topics like parsing, Three Address Code (TAC) generation, and Deterministic Finite Automata (DFA) implementation. Each task builds upon previous knowledge, creating a solid foundation in compiler construction principles.</p>
<br>
<h2 id="learning-objectives">Learning Objectives</h2>
<br>
<p>1. Master string analysis and manipulation techniques in C</p>
<p>2. Understand pattern matching using regular expressions</p>
<p>3. Develop lexical analysis skills for identifier recognition</p>
<p>4. Learn expression parsing and evaluation methods</p>
<p>5. Implement intermediate code generation (TAC)</p>
<p>6. Design and simulate finite automata for pattern recognition</p>
<br>
<hr>
<br>
<h2 id="lab-task-01-string-operations-in-c">LAB TASK 01: String Operations in C</h2>
<br>
<h3>Task 1.1: Count String Length Using Loop</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<p>    int length = 0;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<br>
<p>    // Remove newline character if present</p>
<p>    if (str[strlen(str) - 1] == '\n') {</p>
<p>        str[strlen(str) - 1] = '\0';</p>
<p>    }</p>
<br>
<p>    // Count characters manually</p>
<p>    while (str[length] != '\0') {</p>
<p>        length++;</p>
<p>    }</p>
<br>
<p>    printf("Length of the string is: %d\n", length);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program demonstrates manual string length calculation without using built-in functions like `strlen()`. It iterates through each character until the null terminator is found.</p>
<br>
<h3>Task 1.2: Count how many white spaces (' ') are in a string.</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<p>    int i = 0, spaceCount = 0;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<br>
<p>    if (str[strlen(str) - 1] == '\n') {</p>
<p>        str[strlen(str) - 1] = '\0';</p>
<p>    }</p>
<br>
<p>    while (str[i] != '\0') {</p>
<p>        if (str[i] == ' ') {</p>
<p>            spaceCount++;</p>
<p>        }</p>
<p>        i++;</p>
<p>    }</p>
<br>
<p>    printf("Number of white spaces: %d\n", spaceCount);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program counts the number of space characters in a string by iterating through each character and checking for space (' ') characters.</p>
<br>
<h3>Task 1.3: Remove all white spaces from the input string.</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100], result[100];</p>
<p>    int i = 0, j = 0;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<br>
<p>    if (str[strlen(str) - 1] == '\n') {</p>
<p>        str[strlen(str) - 1] = '\0';</p>
<p>    }</p>
<br>
<p>    while (str[i] != '\0') {</p>
<p>        if (str[i] != ' ') {</p>
<p>            result[j] = str[i];</p>
<p>            j++;</p>
<p>        }</p>
<p>        i++;</p>
<p>    }</p>
<p>    result[j] = '\0';</p>
<br>
<p>    printf("String without white spaces: %s\n", result);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program creates a new string by copying only non-space characters from the original string, effectively removing all white spaces.</p>
<br>
<hr>
<br>
<h2 id="lab-task-02-string-analysis">LAB TASK 02: String Analysis</h2>
<br>
<h3>Task 2.1: Check if a given string is a C keyword (like int, if, etc.). </h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>const char* keywords[] = {</p>
<p>    "auto", "break", "case", "char", "const", "continue",</p>
<p>    "default", "do", "double", "else", "enum", "extern",</p>
<p>    "float", "for", "goto", "if", "int", "long", "register",</p>
<p>    "return", "short", "signed", "sizeof", "static", "struct",</p>
<p>    "switch", "typedef", "union", "unsigned", "void", "volatile",</p>
<p>    "while"</p>
<p>};</p>
<br>
<p>#define NUM_KEYWORDS (sizeof(keywords) / sizeof(keywords[0]))</p>
<br>
<p>int isKeyword(const char* str) {</p>
<p>    for (int i = 0; i < NUM_KEYWORDS; i++) {</p>
<p>        if (strcmp(str, keywords[i]) == 0) {</p>
<p>            return 1;</p>
<p>        }</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char str[50];</p>
<p>    printf("Enter a string: ");</p>
<p>    scanf("%s", str);</p>
<br>
<p>    if (isKeyword(str)) {</p>
<p>        printf("\"%s\" is a C keyword.\n", str);</p>
<p>    } else {</p>
<p>        printf("\"%s\" is NOT a C keyword.\n", str);</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program maintains an array of C keywords and uses string comparison to determine if the input matches any reserved word in C programming language.</p>
<br>
<h3>Task 2.2:  Count the number of vowels, consonants, and digits in a </h3>
<p>string. </p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <ctype.h></p>
<br>
<p>int main() {</p>
<p>    char str[200];</p>
<p>    int vowels = 0, consonants = 0, digits = 0;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = tolower(str[i]);</p>
<br>
<p>        if (ch >= 'a' && ch <= 'z') {</p>
<p>            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')</p>
<p>                vowels++;</p>
<p>            else</p>
<p>                consonants++;</p>
<p>        } else if (ch >= '0' && ch <= '9') {</p>
<p>            digits++;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    printf("Vowels: %d\n", vowels);</p>
<p>    printf("Consonants: %d\n", consonants);</p>
<p>    printf("Digits: %d\n", digits);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program categorizes each character in the input string as vowel, consonant, or digit, providing a complete character analysis.</p>
<br>
<h3>Task 2.3:  Use strtok() to split a string into words (tokens). </h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[200];</p>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<p>    str[strcspn(str, "\n")] = '\0';</p>
<br>
<p>    char* token = strtok(str, " ,.-!?\t");</p>
<p>    printf("Tokens found:\n");</p>
<br>
<p>    while (token != NULL) {</p>
<p>        printf("%s\n", token);</p>
<p>        token = strtok(NULL, " ,.-!?\t");</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program demonstrates the use of `strtok()` function to split a string into tokens based on multiple delimiters including spaces, punctuation, and tabs.</p>
<br>
<h3>Task 2.4:  Count how many tokens were found using strtok(). </h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[200];</p>
<p>    int tokenCount = 0;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<p>    str[strcspn(str, "\n")] = '\0';</p>
<br>
<p>    char* token = strtok(str, " ,.-!?\t");</p>
<br>
<p>    while (token != NULL) {</p>
<p>        tokenCount++;</p>
<p>        token = strtok(NULL, " ,.-!?\t");</p>
<p>    }</p>
<br>
<p>    printf("Total tokens found: %d\n", tokenCount);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program extends the tokenization concept to count the total number of tokens found in the input string.</p>
<br>
<hr>
<br>
<h2 id="lab-task-03-regular-expressions">LAB TASK 03: Regular Expressions</h2>
<br>
<h3>Task 3.1:  a* → Accepts strings with zero or more 'a' (like "", "a", "aaa").</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<p>    int isValid = 1;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    scanf("%s", str);</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        if (str[i] != 'a') {</p>
<p>            isValid = 0;</p>
<p>            break;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    if (isValid) {</p>
<p>        printf("Accepted (Matches a*)\n");</p>
<p>    } else {</p>
<p>        printf("Rejected (Does not match a*)\n");</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program implements the regular expression `a*` which accepts strings containing zero or more 'a' characters only.</p>
<br>
<h3>Task 3.2:  a*b+ → Accepts strings with any number of 'a' followed by </h3>
<p>one or more 'b' (like "b", "ab", "aaab").</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<p>    int i = 0, len, isValid = 1;</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    scanf("%s", str);</p>
<p>    len = strlen(str);</p>
<br>
<p>    // Skip all 'a' characters</p>
<p>    while (str[i] == 'a') {</p>
<p>        i++;</p>
<p>    }</p>
<br>
<p>    // Count 'b' characters</p>
<p>    int bCount = 0;</p>
<p>    while (str[i] == 'b') {</p>
<p>        bCount++;</p>
<p>        i++;</p>
<p>    }</p>
<br>
<p>    // Check if we've consumed all characters and have at least one 'b'</p>
<p>    if (i != len || bCount == 0) {</p>
<p>        isValid = 0;</p>
<p>    }</p>
<br>
<p>    if (isValid) {</p>
<p>        printf("Accepted (Matches a*b+)\n");</p>
<p>    } else {</p>
<p>        printf("Rejected (Does not match a*b+)\n");</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program implements the regular expression `a*b+` which accepts strings with any number of 'a's followed by at least one 'b'.</p>
<br>
<h3>Task 3.3: abb → Only accepts the exact string "abb".</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<br>
<p>    printf("Enter a string: ");</p>
<p>    scanf("%s", str);</p>
<br>
<p>    if (strcmp(str, "abb") == 0) {</p>
<p>        printf("Accepted (Exact match for 'abb')\n");</p>
<p>    } else {</p>
<p>        printf("Rejected (Does not match 'abb')\n");</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program checks for an exact string match with "abb", demonstrating precise pattern matching.</p>
<br>
<hr>
<br>
<h2 id="lab-task-04-lexical-analysis">LAB TASK 04: Lexical Analysis</h2>
<br>
<h3>Task 4.1:  Remove single-line (//) or multi-line (/* */) comments from </h3>
<p>input code.</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char code[5000] = "";</p>
<p>    char line[500];</p>
<br>
<p>    printf("Enter your code (type '#' in a new line to finish):\n");</p>
<p>    while (1) {</p>
<p>        fgets(line, sizeof(line), stdin);</p>
<p>        if (line[0] == '#' && line[1] == '\n')</p>
<p>            break;</p>
<p>        strcat(code, line);</p>
<p>    }</p>
<br>
<p>    for (int i = 0; code[i] != '\0'; i++) {</p>
<p>        if (code[i] == '/' && code[i + 1] == '/') {</p>
<p>            // Skip single-line comment</p>
<p>            while (code[i] != '\n' && code[i] != '\0')</p>
<p>                i++;</p>
<p>        } else if (code[i] == '/' && code[i + 1] == '*') {</p>
<p>            // Skip multi-line comment</p>
<p>            i += 2;</p>
<p>            while (!(code[i] == '*' && code[i + 1] == '/') && code[i] != '\0')</p>
<p>                i++;</p>
<p>            i += 1;</p>
<p>        } else {</p>
<p>            putchar(code[i]);</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program removes both single-line (//) and multi-line (/* */) comments from C code, demonstrating basic lexical analysis.</p>
<br>
<h3>Task 4.2:  Count the articles ("a", "an", "the") in a sentence.</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<p>#include <ctype.h></p>
<br>
<p>int main() {</p>
<p>    char str[1000], word[10];</p>
<p>    int a = 0, an = 0, the = 0;</p>
<p>    int i = 0, j = 0;</p>
<br>
<p>    printf("Enter a sentence: ");</p>
<p>    fgets(str, sizeof(str), stdin);</p>
<br>
<p>    while (str[i]) {</p>
<p>        if (isalpha(str[i])) {</p>
<p>            word[j++] = tolower(str[i]);</p>
<p>        } else {</p>
<p>            if (j > 0) {</p>
<p>                word[j] = '\0';</p>
<p>                if (strcmp(word, "a") == 0) a++;</p>
<p>                else if (strcmp(word, "an") == 0) an++;</p>
<p>                else if (strcmp(word, "the") == 0) the++;</p>
<p>                j = 0;</p>
<p>            }</p>
<p>        }</p>
<p>        i++;</p>
<p>    }</p>
<br>
<p>    // Check last word</p>
<p>    if (j > 0) {</p>
<p>        word[j] = '\0';</p>
<p>        if (strcmp(word, "a") == 0) a++;</p>
<p>        else if (strcmp(word, "an") == 0) an++;</p>
<p>        else if (strcmp(word, "the") == 0) the++;</p>
<p>    }</p>
<br>
<p>    printf("a: %d\nan: %d\nthe: %d\n", a, an, the);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program counts occurrences of articles ("a", "an", "the") in a sentence, useful for natural language processing applications.</p>
<br>
<h3>Task 4.3:  Check if a word is a valid identifier in C (like variable </h3>
<p>name).</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <ctype.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char str[100];</p>
<p>    int i, valid = 1;</p>
<br>
<p>    printf("Enter an identifier: ");</p>
<p>    scanf("%s", str);</p>
<br>
<p>    // First character must be letter or underscore</p>
<p>    if (!(isalpha(str[0]) || str[0] == '_')) {</p>
<p>        valid = 0;</p>
<p>    }</p>
<br>
<p>    // Remaining characters must be alphanumeric or underscore</p>
<p>    for (i = 1; str[i]; i++) {</p>
<p>        if (!(isalnum(str[i]) || str[i] == '_')) {</p>
<p>            valid = 0;</p>
<p>            break;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    if (valid)</p>
<p>        printf("Valid identifier\n");</p>
<p>    else</p>
<p>        printf("Invalid identifier\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program validates C identifiers according to language rules: must start with letter or underscore, followed by alphanumeric characters or underscores.</p>
<br>
<hr>
<br>
<h2 id="lab-task-05-ascii-&-names">LAB TASK 05: ASCII & Names</h2>
<br>
<h3>Task 5.1: Input 3 characters and show the next 3 ASCII characters.</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<br>
<p>int main() {</p>
<p>    char c1, c2, c3;</p>
<br>
<p>    printf("Enter 3 characters: ");</p>
<p>    scanf(" %c %c %c", &c1, &c2, &c3);</p>
<br>
<p>    printf("Next ASCII characters: %c %c %c\n", c1 + 1, c2 + 1, c3 + 1);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 5.2:  Read full name and print the initials (like J.D. for John Doe).</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<br>
<p>int main() {</p>
<p>    char first[50], last[50];</p>
<br>
<p>    printf("Enter first and last name: ");</p>
<p>    scanf("%s %s", first, last);</p>
<br>
<p>    printf("Initials: %c.%c.\n", first[0], last[0]);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 5.3:  Show the ASCII value of a character and the one 5 steps </h3>
<p>ahead.</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<br>
<p>int main() {</p>
<p>    char ch;</p>
<br>
<p>    printf("Enter a character: ");</p>
<p>    scanf(" %c", &ch);</p>
<br>
<p>    printf("ASCII of %c: %d\n", ch, ch);</p>
<p>    printf("ASCII 5 steps ahead: %d (%c)\n", ch + 5, ch + 5);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 5.4: Input full name (up to 3 words) and show all initials. </h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int main() {</p>
<p>    char name[100];</p>
<p>    int i;</p>
<br>
<p>    printf("Enter full name (up to 3 words): ");</p>
<p>    fgets(name, sizeof(name), stdin);</p>
<br>
<p>    for (i = 0; name[i] != '\0'; i++) {</p>
<p>        if (i == 0 && name[i] != ' ') {</p>
<p>            printf("%c.", name[i]);</p>
<p>        } else if (name[i] == ' ' && name[i + 1] != ' ' && </p>
<p>                   name[i + 1] != '\0' && name[i + 1] != '\n') {</p>
<p>            printf("%c.", name[i + 1]);</p>
<p>        }</p>
<p>    }</p>
<p>    printf("\n");</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> These tasks demonstrate ASCII manipulation and string processing for name handling, common in text processing applications.</p>
<br>
<hr>
<br>
<h2 id="lab-task-06-make-a-basic-calculator-that-follows-math-rules-(like-*-">LAB TASK 06: Make a basic calculator that follows math rules (like * </h2>
<p>before +) using a method called recursive descent parser.</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <stdlib.h></p>
<p>#include <ctype.h></p>
<p>#include <math.h></p>
<p>#include <string.h></p>
<br>
<p>char input[100];</p>
<p>int pos = 0;</p>
<br>
<p>int getNextToken() {</p>
<p>    while (input[pos] == ' ')</p>
<p>        pos++;</p>
<p>    return input[pos++];</p>
<p>}</p>
<br>
<p>void putBackToken() {</p>
<p>    pos--;</p>
<p>}</p>
<br>
<p>int parseExpr();</p>
<p>int parseTerm();</p>
<p>int parsePower();</p>
<br>
<p>int parseFactor() {</p>
<p>    int token = getNextToken();</p>
<br>
<p>    if (isdigit(token)) {</p>
<p>        int value = token - '0';</p>
<p>        while (isdigit(input[pos])) {</p>
<p>            value = value * 10 + (input[pos++] - '0');</p>
<p>        }</p>
<p>        return value;</p>
<p>    } else if (token == '(') {</p>
<p>        int result = parseExpr();</p>
<p>        if (getNextToken() != ')') {</p>
<p>            printf("Error: Missing ')'\n");</p>
<p>            exit(1);</p>
<p>        }</p>
<p>        return result;</p>
<p>    } else {</p>
<p>        printf("Error: Expected number or '('\n");</p>
<p>        exit(1);</p>
<p>    }</p>
<p>}</p>
<br>
<p>int parsePower() {</p>
<p>    int base = parseFactor();</p>
<p>    int token = getNextToken();</p>
<br>
<p>    if (token == '^') {</p>
<p>        int exponent = parsePower();</p>
<p>        return pow(base, exponent);</p>
<p>    } else {</p>
<p>        putBackToken();</p>
<p>        return base;</p>
<p>    }</p>
<p>}</p>
<br>
<p>int parseTerm() {</p>
<p>    int result = parsePower();</p>
<p>    int token = getNextToken();</p>
<br>
<p>    while (token == '*' || token == '/') {</p>
<p>        if (token == '*') {</p>
<p>            result *= parsePower();</p>
<p>        } else {</p>
<p>            int divisor = parsePower();</p>
<p>            if (divisor == 0) {</p>
<p>                printf("Error: Division by zero\n");</p>
<p>                exit(1);</p>
<p>            }</p>
<p>            result /= divisor;</p>
<p>        }</p>
<p>        token = getNextToken();</p>
<p>    }</p>
<br>
<p>    putBackToken();</p>
<p>    return result;</p>
<p>}</p>
<br>
<p>int parseExpr() {</p>
<p>    int result = parseTerm();</p>
<p>    int token = getNextToken();</p>
<br>
<p>    while (token == '+' || token == '-') {</p>
<p>        if (token == '+') {</p>
<p>            result += parseTerm();</p>
<p>        } else {</p>
<p>            result -= parseTerm();</p>
<p>        }</p>
<p>        token = getNextToken();</p>
<p>    }</p>
<br>
<p>    putBackToken();</p>
<p>    return result;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    printf("Enter an arithmetic expression: ");</p>
<p>    fgets(input, sizeof(input), stdin);</p>
<br>
<p>    size_t len = strlen(input);</p>
<p>    if (len > 0 && input[len - 1] == '\n') {</p>
<p>        input[len - 1] = '\0';</p>
<p>    }</p>
<br>
<p>    int result = parseExpr();</p>
<p>    printf("Result: %d\n", result);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This recursive descent parser evaluates arithmetic expressions while respecting operator precedence (parentheses, exponents, multiplication/division, addition/subtraction).</p>
<br>
<hr>
<br>
<h2 id="lab-task-07-convert-expressions-into-tac-format,-which-is-used-in-">LAB TASK 07: Convert expressions into TAC format, which is used in </h2>
<p>compiler design (e.g., t1 = a + b).</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<p>#include <stdlib.h></p>
<p>#include <ctype.h></p>
<br>
<p>#define MAX 100</p>
<p>int tempVarCount = 1;</p>
<br>
<p>int isValidIdentifier(char *s) {</p>
<p>    if (!isalpha(s[0]))</p>
<p>        return 0;</p>
<p>    for (int i = 1; s[i]; i++) {</p>
<p>        if (!isalnum(s[i]))</p>
<p>            return 0;</p>
<p>    }</p>
<p>    return 1;</p>
<p>}</p>
<br>
<p>void getTemp(char *temp) {</p>
<p>    sprintf(temp, "t%d", tempVarCount++);</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[MAX], lhs[20];</p>
<p>    char tokens[50][20];</p>
<p>    int tokenCount = 0;</p>
<br>
<p>    printf("Enter expression (e.g., a = b + c + d + e):\n> ");</p>
<p>    fgets(input, MAX, stdin);</p>
<p>    input[strcspn(input, "\n")] = '\0';</p>
<br>
<p>    char *token = strtok(input, " ");</p>
<p>    while (token != NULL) {</p>
<p>        strcpy(tokens[tokenCount++], token);</p>
<p>        token = strtok(NULL, " ");</p>
<p>    }</p>
<br>
<p>    if (tokenCount < 5 || strcmp(tokens[1], "=") != 0) {</p>
<p>        printf("Error: Invalid format. Use format like: a = b + c + d\n");</p>
<p>        return 1;</p>
<p>    }</p>
<br>
<p>    strcpy(lhs, tokens[0]);</p>
<p>    if (!isValidIdentifier(lhs)) {</p>
<p>        printf("Error: Invalid identifier on LHS.\n");</p>
<p>        return 1;</p>
<p>    }</p>
<br>
<p>    printf("\nThree Address Code:\n");</p>
<br>
<p>    char prevTemp[20], temp[20];</p>
<p>    char op1[20], op2[20], oper;</p>
<br>
<p>    strcpy(op1, tokens[2]);</p>
<p>    strcpy(op2, tokens[4]);</p>
<p>    oper = tokens[3][0];</p>
<br>
<p>    getTemp(temp);</p>
<p>    printf("%s = %s %c %s\n", temp, op1, oper, op2);</p>
<p>    strcpy(prevTemp, temp);</p>
<br>
<p>    for (int i = 5; i < tokenCount; i += 2) {</p>
<p>        if (i + 1 >= tokenCount) {</p>
<p>            printf("Error: Operator without operand.\n");</p>
<p>            return 1;</p>
<p>        }</p>
<br>
<p>        oper = tokens[i][0];</p>
<p>        strcpy(op2, tokens[i + 1]);</p>
<br>
<p>        getTemp(temp);</p>
<p>        printf("%s = %s %c %s\n", temp, prevTemp, oper, op2);</p>
<p>        strcpy(prevTemp, temp);</p>
<p>    }</p>
<br>
<p>    printf("%s = %s\n", lhs, prevTemp);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program converts complex arithmetic expressions into Three Address Code format, which is an intermediate representation used in compiler design for optimization and code generation.</p>
<br>
<hr>
<br>
<h2 id="lab-task-08-create-a-parser-in-c-to-analyze-and-evaluate-math-">LAB TASK 08: Create a parser in C to analyze and evaluate math </h2>
<p>expressions using grammar rules.</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <ctype.h></p>
<p>#include <string.h></p>
<p>#include <stdlib.h></p>
<br>
<p>char input[100];</p>
<p>int pos = 0;</p>
<p>char currentChar;</p>
<br>
<p>void error() {</p>
<p>    printf("Invalid Expression\n");</p>
<p>    exit(1);</p>
<p>}</p>
<br>
<p>void advance() {</p>
<p>    currentChar = input[pos++];</p>
<p>}</p>
<br>
<p>void match(char expected) {</p>
<p>    if (currentChar == expected)</p>
<p>        advance();</p>
<p>    else</p>
<p>        error();</p>
<p>}</p>
<br>
<p>void E();</p>
<p>void Eprime();</p>
<p>void T();</p>
<p>void Tprime();</p>
<p>void F();</p>
<br>
<p>void E() {</p>
<p>    T();</p>
<p>    Eprime();</p>
<p>}</p>
<br>
<p>void Eprime() {</p>
<p>    if (currentChar == '+' || currentChar == '-') {</p>
<p>        char op = currentChar;</p>
<p>        advance();</p>
<p>        T();</p>
<p>        Eprime();</p>
<p>    }</p>
<p>}</p>
<br>
<p>void T() {</p>
<p>    F();</p>
<p>    Tprime();</p>
<p>}</p>
<br>
<p>void Tprime() {</p>
<p>    if (currentChar == '*' || currentChar == '/') {</p>
<p>        char op = currentChar;</p>
<p>        advance();</p>
<p>        F();</p>
<p>        Tprime();</p>
<p>    }</p>
<p>}</p>
<br>
<p>void F() {</p>
<p>    if (isalpha(currentChar)) {</p>
<p>        advance();</p>
<p>    } else if (currentChar == '(') {</p>
<p>        advance();</p>
<p>        E();</p>
<p>        if (currentChar == ')') {</p>
<p>            advance();</p>
<p>        } else {</p>
<p>            error();</p>
<p>        }</p>
<p>    } else {</p>
<p>        error();</p>
<p>    }</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    printf("Enter an expression: ");</p>
<p>    fgets(input, sizeof(input), stdin);</p>
<p>    input[strcspn(input, "\n")] = '\0';</p>
<br>
<p>    pos = 0;</p>
<p>    advance();</p>
<p>    E();</p>
<br>
<p>    if (currentChar == '\0')</p>
<p>        printf("Expression is Valid\n");</p>
<p>    else</p>
<p>        printf("Invalid Expression\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This recursive descent parser validates arithmetic expressions based on formal grammar rules, demonstrating syntax analysis in compiler design.</p>
<br>
<hr>
<br>
<h2 id="lab-task-09--convert-normal-math-expressions-(like-a-+-b)-into-postfix-">LAB TASK 09:  Convert normal math expressions (like a + b) into postfix </h2>
<p>form (ab+) using a stack.</p>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <stdlib.h></p>
<p>#include <ctype.h></p>
<br>
<p>#define MAX 100</p>
<br>
<p>char stack[MAX];</p>
<p>int top = -1;</p>
<br>
<p>void push(char c) {</p>
<p>    stack[++top] = c;</p>
<p>}</p>
<br>
<p>char pop() {</p>
<p>    if (top == -1)</p>
<p>        return -1;</p>
<p>    return stack[top--];</p>
<p>}</p>
<br>
<p>char peek() {</p>
<p>    if (top == -1)</p>
<p>        return -1;</p>
<p>    return stack[top];</p>
<p>}</p>
<br>
<p>int precedence(char op) {</p>
<p>    if (op == '+' || op == '-')</p>
<p>        return 1;</p>
<p>    if (op == '*' || op == '/')</p>
<p>        return 2;</p>
<p>    return 0;</p>
<p>}</p>
<br>
<p>void infixToPostfix(char *exp) {</p>
<p>    char *e = exp;</p>
<p>    char ch;</p>
<br>
<p>    printf("Postfix: ");</p>
<br>
<p>    while (*e != '\0') {</p>
<p>        if (isalnum(*e)) {</p>
<p>            printf("%c ", *e);</p>
<p>        } else if (*e == '(') {</p>
<p>            push(*e);</p>
<p>        } else if (*e == ')') {</p>
<p>            while ((ch = pop()) != '(')</p>
<p>                printf("%c ", ch);</p>
<p>        } else {</p>
<p>            while (precedence(peek()) >= precedence(*e))</p>
<p>                printf("%c ", pop());</p>
<p>            push(*e);</p>
<p>        }</p>
<p>        e++;</p>
<p>    }</p>
<br>
<p>    while (top != -1)</p>
<p>        printf("%c ", pop());</p>
<br>
<p>    printf("\n");</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char expression[MAX];</p>
<br>
<p>    printf("Enter infix expression (e.g., a+b*c): ");</p>
<p>    scanf("%s", expression);</p>
<br>
<p>    infixToPostfix(expression);</p>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> This program converts infix expressions to postfix notation using the shunting yard algorithm, which is fundamental for expression evaluation in compilers and calculators.</p>
<br>
<hr>
<br>
<h2 id="lab-task-10-deterministic-finite-automata-(dfa)">LAB TASK 10: Deterministic Finite Automata (DFA)</h2>
<br>
<h3>Task 10.1: DFA for Strings Starting with "10"</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int dfa_startsWith10(char *str) {</p>
<p>    int state = 0;</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = str[i];</p>
<br>
<p>        switch (state) {</p>
<p>            case 0:</p>
<p>                if (ch == '1')</p>
<p>                    state = 1;</p>
<p>                else</p>
<p>                    state = 3; // reject state</p>
<p>                break;</p>
<p>            case 1:</p>
<p>                if (ch == '0')</p>
<p>                    state = 2; // accept state</p>
<p>                else</p>
<p>                    state = 3; // reject state</p>
<p>                break;</p>
<p>            case 2:</p>
<p>                if (ch == '0' || ch == '1')</p>
<p>                    state = 2; // stay in accept state</p>
<p>                else</p>
<p>                    state = 3; // reject state</p>
<p>                break;</p>
<p>            case 3:</p>
<p>                return 0; // reject</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return state == 2;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[100];</p>
<br>
<p>    printf("Enter a binary string: ");</p>
<p>    scanf("%s", input);</p>
<br>
<p>    if (dfa_startsWith10(input))</p>
<p>        printf("Accepted: String starts with '10'\n");</p>
<p>    else</p>
<p>        printf("Rejected: Does NOT start with '10'\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 10.2: DFA for Strings Ending with "01"</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int dfa_endsWith01(char *str) {</p>
<p>    int state = 0;</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = str[i];</p>
<br>
<p>        switch (state) {</p>
<p>            case 0:</p>
<p>                if (ch == '0') state = 1;</p>
<p>                else if (ch == '1') state = 0;</p>
<p>                else return 0;</p>
<p>                break;</p>
<p>            case 1:</p>
<p>                if (ch == '0') state = 1;</p>
<p>                else if (ch == '1') state = 2;</p>
<p>                else return 0;</p>
<p>                break;</p>
<p>            case 2:</p>
<p>                if (ch == '0') state = 1;</p>
<p>                else if (ch == '1') state = 0;</p>
<p>                else return 0;</p>
<p>                break;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return state == 2;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[100];</p>
<br>
<p>    printf("Enter a binary string: ");</p>
<p>    scanf("%s", input);</p>
<br>
<p>    if (dfa_endsWith01(input))</p>
<p>        printf("Accepted: String ends with '01'\n");</p>
<p>    else</p>
<p>        printf("Rejected: Does NOT end with '01'\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 10.3: DFA for Exactly One '0'</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int dfa_exactlyOneZero(char *str) {</p>
<p>    int state = 0;</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = str[i];</p>
<br>
<p>        switch (state) {</p>
<p>            case 0: // no zeros seen</p>
<p>                if (ch == '0') state = 1;</p>
<p>                else if (ch == '1') state = 0;</p>
<p>                else return 0;</p>
<p>                break;</p>
<p>            case 1: // exactly one zero seen</p>
<p>                if (ch == '0') state = 2; // too many zeros</p>
<p>                else if (ch == '1') state = 1;</p>
<p>                else return 0;</p>
<p>                break;</p>
<p>            case 2: // more than one zero seen</p>
<p>                return 0;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return state == 1;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[100];</p>
<br>
<p>    printf("Enter a binary string: ");</p>
<p>    scanf("%s", input);</p>
<br>
<p>    if (dfa_exactlyOneZero(input))</p>
<p>        printf("Accepted: String contains exactly one '0'\n");</p>
<p>    else</p>
<p>        printf("Rejected: Does NOT contain exactly one '0'\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 10.4: DFA for Strings Containing "01"</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int dfa_contains01(char *str) {</p>
<p>    int state = 0;</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = str[i];</p>
<br>
<p>        switch (state) {</p>
<p>            case 0:</p>
<p>                if (ch == '0')</p>
<p>                    state = 1;</p>
<p>                else if (ch == '1')</p>
<p>                    state = 0;</p>
<p>                else</p>
<p>                    return 0;</p>
<p>                break;</p>
<p>            case 1:</p>
<p>                if (ch == '1')</p>
<p>                    state = 2; // found "01"</p>
<p>                else if (ch == '0')</p>
<p>                    state = 1;</p>
<p>                else</p>
<p>                    return 0;</p>
<p>                break;</p>
<p>            case 2:</p>
<p>                state = 2; // stay in accept state</p>
<p>                break;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return state == 2;</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[100];</p>
<br>
<p>    printf("Enter a binary string: ");</p>
<p>    scanf("%s", input);</p>
<br>
<p>    if (dfa_contains01(input))</p>
<p>        printf("Accepted: String contains '01'\n");</p>
<p>    else</p>
<p>        printf("Rejected: String does NOT contain '01'\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<h3>Task 10.5: DFA for Even Number of '0's</h3>
<br>
<pre><code class="language-c">
<p>#include <stdio.h></p>
<p>#include <string.h></p>
<br>
<p>int dfa_evenZeros(char *str) {</p>
<p>    int state = 0; // state 0: even number of zeros, state 1: odd number of zeros</p>
<br>
<p>    for (int i = 0; str[i] != '\0'; i++) {</p>
<p>        char ch = str[i];</p>
<br>
<p>        switch (state) {</p>
<p>            case 0: // even number of zeros</p>
<p>                if (ch == '0')</p>
<p>                    state = 1; // now odd</p>
<p>                else if (ch == '1')</p>
<p>                    state = 0; // stay even</p>
<p>                else</p>
<p>                    return 0;</p>
<p>                break;</p>
<p>            case 1: // odd number of zeros</p>
<p>                if (ch == '0')</p>
<p>                    state = 0; // now even</p>
<p>                else if (ch == '1')</p>
<p>                    state = 1; // stay odd</p>
<p>                else</p>
<p>                    return 0;</p>
<p>                break;</p>
<p>        }</p>
<p>    }</p>
<br>
<p>    return state == 0; // accept if even number of zeros</p>
<p>}</p>
<br>
<p>int main() {</p>
<p>    char input[100];</p>
<br>
<p>    printf("Enter a binary string: ");</p>
<p>    scanf("%s", input);</p>
<br>
<p>    if (dfa_evenZeros(input))</p>
<p>        printf("Accepted: Even number of '0's\n");</p>
<p>    else</p>
<p>        printf("Rejected: Odd number of '0's\n");</p>
<br>
<p>    return 0;</p>
<p>}</p>
</code></pre>
<div class="sample-output">Sample Output: (Write here)</div>
<br>
<p><strong>Explanation:</strong> These DFA implementations demonstrate finite state machine design for pattern recognition. Each DFA has specific states representing different conditions, and transitions between states are determined by input characters. This is fundamental to lexical analysis in compilers.</p>
<br>
<hr>
<br>
<h2 id="key-concepts-learned">Key Concepts Learned</h2>
<br>
<h3>1. String Manipulation</h3>
<p>- Manual string operations without built-in functions</p>
<p>- Character-by-character processing</p>
<p>- Memory management for string operations</p>
<br>
<h3>2. Pattern Matching</h3>
<p>- Regular expression implementation</p>
<p>- Finite state machines for pattern recognition</p>
<p>- Complex pattern validation</p>
<br>
<h3>3. Lexical Analysis</h3>
<p>- Token recognition and classification</p>
<p>- Comment removal from source code</p>
<p>- Identifier validation according to language rules</p>
<br>
<h3>4. Parsing Techniques</h3>
<p>- Recursive descent parsing</p>
<p>- Operator precedence handling</p>
<p>- Syntax validation using formal grammars</p>
<br>
<h3>5. Intermediate Code Generation</h3>
<p>- Three Address Code (TAC) generation</p>
<p>- Expression transformation for compiler optimization</p>
<p>- Temporary variable management</p>
<br>
<h3>6. Expression Processing</h3>
<p>- Infix to postfix conversion using stack</p>
<p>- Expression evaluation with proper precedence</p>
<p>- Parentheses handling in complex expressions</p>
<br>
<h3>7. Finite Automata Design</h3>
<p>- State machine implementation in C</p>
<p>- Pattern recognition using DFA</p>
<p>- Multiple acceptance criteria handling</p>
<br>
<hr>
<br>
<h2 id="conclusion">Conclusion</h2>
<br>
<p>This comprehensive lab portfolio demonstrates the practical implementation of fundamental concepts in formal languages and compiler design. Through these 10 tasks, I have gained hands-on experience in:</p>
<br>
<p>**Core Programming Skills:**</p>
<p>- Advanced string manipulation techniques in C</p>
<p>- Memory management and efficient algorithm implementation</p>
<p>- Error handling and input validation</p>
<br>
<p>**Compiler Design Fundamentals:**</p>
<p>- Lexical analysis through tokenization and pattern matching</p>
<p>- Syntax analysis using recursive descent parsing</p>
<p>- Intermediate code generation with Three Address Code</p>
<p>- Expression evaluation with proper operator precedence</p>
<br>
<p>**Theoretical Concepts in Practice:**</p>
<p>- Regular expression implementation for pattern matching</p>
<p>- Finite automata design and simulation</p>
<p>- Grammar-based parsing and validation</p>
<p>- Stack-based algorithms for expression processing</p>
<br>
<p>**Problem-Solving Abilities:**</p>
<p>- Breaking complex problems into manageable components</p>
<p>- Implementing theoretical concepts in practical code</p>
<p>- Debugging and testing compiler-related algorithms</p>
<br>
<p>The progression from basic string operations to complex parsing and automata design has provided a solid foundation in compiler construction principles. These skills are essential for understanding how programming languages are processed, from source code to executable programs.</p>
<br>
<p>The implementation of DFAs for various pattern recognition tasks demonstrates the practical application of finite state machines in real-world scenarios such as lexical analysis, input validation, and protocol design. The parsing exercises show how formal grammars translate into working code that can analyze and validate complex expressions.</p>
<br>
<p>This portfolio represents not just a collection of programming exercises, but a comprehensive journey through the core concepts that underpin modern compiler design and formal language theory. The skills developed here are directly applicable to advanced topics in compiler construction, interpreter design, and language processing systems.</p>
<br>
<p>**Future Applications:**</p>
<p>These concepts serve as building blocks for more advanced compiler topics including:</p>
<p>- Advanced parsing techniques (LR, LALR)</p>
<p>- Semantic analysis and type checking</p>
<p>- Code optimization techniques</p>
<p>- Target code generation</p>
<p>- Error recovery and reporting systems</p>
<br>
<p>The practical experience gained through these implementations provides a strong foundation for tackling real-world compiler design challenges and understanding the inner workings of programming language processors.</p>
